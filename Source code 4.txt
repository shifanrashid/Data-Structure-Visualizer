#include <SFML/Graphics.hpp>
#include <iostream>
#include <vector>
#include <unordered_map>

int main() {
    // Create a window
    sf::RenderWindow window(sf::VideoMode(800, 600), "Data Structure & Algorithm Visualizer", sf::Style::Close);

    // Load font
    sf::Font font;
    if (!font.loadFromFile("arial.ttf")) {
        std::cerr << "Error loading font!" << std::endl;
        return -1;
    }

    // Create title text for the main menu
    sf::Text titleText;
    titleText.setFont(font);
    titleText.setString("Data Structures & Algorithm Visualization");
    titleText.setCharacterSize(36);
    titleText.setFillColor(sf::Color::White);
    titleText.setStyle(sf::Text::Bold);
    titleText.setPosition(
        (800 - titleText.getLocalBounds().width) / 2,
        50
    );

    // Button labels
    std::vector<std::string> algorithms = {"Stacks", "Queues", "Trees", "Graphs", "Algorithms"};
    std::vector<sf::RectangleShape> buttons;
    std::vector<sf::Text> buttonTexts;

    // Create buttons and texts for the main menu
    sf::Vector2f buttonSize(200, 50);
    float startY = 180;

    for (size_t i = 0; i < algorithms.size(); ++i) {
        sf::RectangleShape button(buttonSize);
        button.setPosition(315, startY + i * 70);
        button.setFillColor(sf::Color(100, 100, 200));
        button.setOutlineThickness(2);
        button.setOutlineColor(sf::Color::White);
        buttons.push_back(button);

        sf::Text buttonText;
        buttonText.setFont(font);
        buttonText.setString(algorithms[i]);
        buttonText.setCharacterSize(18);
        buttonText.setFillColor(sf::Color::White);
        buttonText.setPosition(
            button.getPosition().x + (buttonSize.x - buttonText.getLocalBounds().width) / 2,
            button.getPosition().y + (buttonSize.y - buttonText.getLocalBounds().height) / 2 - 5
        );
        buttonTexts.push_back(buttonText);
    }

    // Descriptions for each algorithm page
    std::unordered_map<std::string, std::string> descriptions = {
        {"Stacks", "A stack is a data structure that follows the LIFO principle: Last In, First Out."},
        {"Queues", "A queue is a data structure that follows the FIFO principle: First In, First Out."},
        {"Trees", "A tree is a hierarchical data structure consisting of nodes connected by edges."},
        {"Graphs", "A graph is a set of vertices connected by edges, useful for network modeling."},
        {"Algorithms", "Algorithms are step-by-step procedures for solving problems or performing tasks."}
    };

    // Create Back button
    sf::RectangleShape backButton(sf::Vector2f(100, 40));
    backButton.setPosition(10, 10); // Position in the upper-left corner
    backButton.setFillColor(sf::Color(100, 100, 200));
    backButton.setOutlineThickness(2);
    backButton.setOutlineColor(sf::Color::White);

    sf::Text backButtonText;
    backButtonText.setFont(font);
    backButtonText.setString("Back");
    backButtonText.setCharacterSize(18);
    backButtonText.setFillColor(sf::Color::White);
    backButtonText.setPosition(
        backButton.getPosition().x + (backButton.getSize().x - backButtonText.getLocalBounds().width) / 2,
        backButton.getPosition().y + (backButton.getSize().y - backButtonText.getLocalBounds().height) / 2 - 5
    );

    // Create Visualize button
    sf::RectangleShape visualizeButton(sf::Vector2f(150, 50));
    visualizeButton.setPosition(325, 500); // Bottom-center position
    visualizeButton.setFillColor(sf::Color(100, 200, 100));
    visualizeButton.setOutlineThickness(2);
    visualizeButton.setOutlineColor(sf::Color::White);

    sf::Text visualizeButtonText;
    visualizeButtonText.setFont(font);
    visualizeButtonText.setString("Visualize");
    visualizeButtonText.setCharacterSize(18);
    visualizeButtonText.setFillColor(sf::Color::White);
    visualizeButtonText.setPosition(
        visualizeButton.getPosition().x + (visualizeButton.getSize().x - visualizeButtonText.getLocalBounds().width) / 2,
        visualizeButton.getPosition().y + (visualizeButton.getSize().y - visualizeButtonText.getLocalBounds().height) / 2 - 5
    );

    // State variable to track which page to display
    bool showMainPage = true;
    std::string currentAlgorithm = "";

    // Main loop
    while (window.isOpen()) {
        sf::Event event;
        while (window.pollEvent(event)) {
            if (event.type == sf::Event::Closed)
                window.close();

            if (event.type == sf::Event::MouseButtonPressed) {
                if (event.mouseButton.button == sf::Mouse::Left) {
                    sf::Vector2f mousePos(event.mouseButton.x, event.mouseButton.y);

                    if (showMainPage) {
                        // Check if any main menu button is clicked
                        for (size_t i = 0; i < buttons.size(); ++i) {
                            if (buttons[i].getGlobalBounds().contains(mousePos)) {
                                currentAlgorithm = algorithms[i];
                                std::cout << "Navigating to page for: " << currentAlgorithm << std::endl;
                                showMainPage = false; // Switch to algorithm page
                            }
                        }
                    } else {
                        // Check if the Back button is clicked
                        if (backButton.getGlobalBounds().contains(mousePos)) {
                            std::cout << "Returning to main menu..." << std::endl;
                            showMainPage = true; // Return to main menu
                        }

                        // Check if the Visualize button is clicked
                        if (visualizeButton.getGlobalBounds().contains(mousePos)) {
                            std::cout << "Starting visualization for: " << currentAlgorithm << std::endl;
                            // Add visualization logic here
                        }
                    }
                }
            }
        }

        // Render
        window.clear(sf::Color(50, 50, 50));

        if (showMainPage) {
            // Render main menu
            window.draw(titleText);
            for (size_t i = 0; i < buttons.size(); ++i) {
                window.draw(buttons[i]);
                window.draw(buttonTexts[i]);
            }
        } else {
            // Render algorithm page
            sf::Text algorithmTitle;
            algorithmTitle.setFont(font);
            algorithmTitle.setString(currentAlgorithm + " Visualization");
            algorithmTitle.setCharacterSize(30);
            algorithmTitle.setFillColor(sf::Color::White);
            algorithmTitle.setPosition(
                (800 - algorithmTitle.getLocalBounds().width) / 2,
                50
            );
            window.draw(algorithmTitle);

            sf::Text descriptionText;
            descriptionText.setFont(font);
            descriptionText.setString("Description: " + descriptions[currentAlgorithm]);
            descriptionText.setCharacterSize(18);
            descriptionText.setFillColor(sf::Color::White);
            descriptionText.setPosition(50, 150);
            window.draw(descriptionText);

            // Draw the Back button
            window.draw(backButton);
            window.draw(backButtonText);

            // Draw the Visualize button
            window.draw(visualizeButton);
            window.draw(visualizeButtonText);
        }

        window.display();
    }

    return 0;
}
