#include <SFML/Graphics.hpp>
#include <iostream>
#include <vector>
#include <unordered_map>

int main() {
    // Create a window with resize, minimize, and maximize options
    sf::RenderWindow window(sf::VideoMode(800, 600), "Data Structure & Algorithm Visualizer", sf::Style::Default);

    // Load font
    sf::Font font;
    if (!font.loadFromFile("arial.ttf")) {
        std::cerr << "Error loading font!" << std::endl;
        return -1;
    }

    // Create title text
    sf::Text titleText;
    titleText.setFont(font);
    titleText.setString("Data Structures & Algorithm Visualization");
    titleText.setCharacterSize(36);
    titleText.setFillColor(sf::Color::White);
    titleText.setStyle(sf::Text::Bold);

    // Button labels
    std::vector<std::string> algorithms = {"Stacks", "Queues", "Trees", "Graphs", "Algorithms"};
    std::vector<sf::RectangleShape> buttons(algorithms.size());
    std::vector<sf::Text> buttonTexts(algorithms.size());

    // Create Back button
    sf::RectangleShape backButton(sf::Vector2f(100, 40));
    backButton.setFillColor(sf::Color(100, 100, 200));
    backButton.setOutlineThickness(2);
    backButton.setOutlineColor(sf::Color::White);

    sf::Text backButtonText;
    backButtonText.setFont(font);
    backButtonText.setString("Back");
    backButtonText.setCharacterSize(18);
    backButtonText.setFillColor(sf::Color::White);

    // Create Visualize button
    sf::RectangleShape visualizeButton(sf::Vector2f(150, 50));
    visualizeButton.setFillColor(sf::Color(100, 200, 100));
    visualizeButton.setOutlineThickness(2);
    visualizeButton.setOutlineColor(sf::Color::White);

    sf::Text visualizeButtonText;
    visualizeButtonText.setFont(font);
    visualizeButtonText.setString("Visualize");
    visualizeButtonText.setCharacterSize(18);
    visualizeButtonText.setFillColor(sf::Color::White);

    // Data for each section
    struct DataStructureInfo {
        std::string description;
        std::string bestComplexity;
        std::string averageComplexity;
        std::string advantages;
        std::string disadvantages;
    };

    std::unordered_map<std::string, DataStructureInfo> dataStructures = {
        {"Stacks", {
            "A stack is a LIFO (Last In, First Out) data structure.",
            "O(1) for push/pop",
            "O(1) for push/pop",
            "Simple implementation, efficient for backtracking (e.g., undo operations).",
            "Limited size in static stacks, no random access."
        }},
        {"Queues", {
            "A queue is a FIFO (First In, First Out) data structure.",
            "O(1) for enqueue/dequeue",
            "O(1) for enqueue/dequeue",
            "Efficient for scheduling tasks (e.g., printers, processes).",
            "Limited size in static queues, no reverse traversal."
        }},
        {"Graphs", {
            "A graph consists of nodes (vertices) connected by edges.",
            "Depends on the algorithm (e.g., O(V+E) for BFS/DFS)",
            "Depends on the algorithm",
            "Models networks like social media, roadmaps.",
            "Complex to implement and process in large graphs."
        }},
        // "Trees" and "Algorithms" pages are placeholders
        {"Trees", {
            "", "", "", "", ""
        }},
        {"Algorithms", {
            "", "", "", "", ""
        }}
    };

    // State variables
    bool showMainPage = true;
    std::string currentAlgorithm = "";

    // Create a view for resizing
    sf::View view(sf::FloatRect(0, 0, 800, 600));

    // Function to update the layout dynamically
    auto updateLayout = [&](sf::Vector2u windowSize) {
        float windowWidth = static_cast<float>(windowSize.x);
        float windowHeight = static_cast<float>(windowSize.y);

        // Update title position
        titleText.setPosition((windowWidth - titleText.getLocalBounds().width) / 2, 50);

        // Update button positions
        float buttonWidth = 200;
        float buttonHeight = 50;
        float startY = windowHeight * 0.3f;
        float buttonSpacing = 20;

        for (size_t i = 0; i < buttons.size(); ++i) {
            buttons[i].setSize(sf::Vector2f(buttonWidth, buttonHeight));
            buttons[i].setPosition(
                (windowWidth - buttonWidth) / 2,
                startY + i * (buttonHeight + buttonSpacing)
            );
            buttons[i].setFillColor(sf::Color(100, 100, 200));
            buttons[i].setOutlineThickness(2);
            buttons[i].setOutlineColor(sf::Color::White);

            buttonTexts[i].setFont(font);
            buttonTexts[i].setString(algorithms[i]);
            buttonTexts[i].setCharacterSize(18);
            buttonTexts[i].setFillColor(sf::Color::White);
            buttonTexts[i].setPosition(
                buttons[i].getPosition().x + (buttonWidth - buttonTexts[i].getLocalBounds().width) / 2,
                buttons[i].getPosition().y + (buttonHeight - buttonTexts[i].getLocalBounds().height) / 2 - 5
            );
        }

        // Update Back button
        backButton.setPosition(10, 10);
        backButtonText.setPosition(
            backButton.getPosition().x + (backButton.getSize().x - backButtonText.getLocalBounds().width) / 2,
            backButton.getPosition().y + (backButton.getSize().y - backButtonText.getLocalBounds().height) / 2 - 5
        );

        // Update Visualize button
        visualizeButton.setPosition((windowWidth - visualizeButton.getSize().x) / 2, windowHeight - 100);
        visualizeButtonText.setPosition(
            visualizeButton.getPosition().x + (visualizeButton.getSize().x - visualizeButtonText.getLocalBounds().width) / 2,
            visualizeButton.getPosition().y + (visualizeButton.getSize().y - visualizeButtonText.getLocalBounds().height) / 2 - 5
        );
    };

    // Initialize layout
    updateLayout(window.getSize());

    // Main loop
    while (window.isOpen()) {
        sf::Event event;
        while (window.pollEvent(event)) {
            if (event.type == sf::Event::Closed)
                window.close();

            if (event.type == sf::Event::Resized) {
                sf::Vector2u newSize(event.size.width, event.size.height);
                view.setSize(static_cast<float>(newSize.x), static_cast<float>(newSize.y));
                view.setCenter(newSize.x / 2.0f, newSize.y / 2.0f);
                window.setView(view);

                updateLayout(newSize);
            }

            if (event.type == sf::Event::MouseButtonPressed) {
                if (event.mouseButton.button == sf::Mouse::Left) {
                    sf::Vector2f mousePos = window.mapPixelToCoords({event.mouseButton.x, event.mouseButton.y});

                    if (showMainPage) {
                        for (size_t i = 0; i < buttons.size(); ++i) {
                            if (buttons[i].getGlobalBounds().contains(mousePos)) {
                                currentAlgorithm = algorithms[i];
                                showMainPage = false;
                                break;
                            }
                        }
                    } else {
                        if (backButton.getGlobalBounds().contains(mousePos)) {
                            showMainPage = true;
                        }
                    }
                }
            }
        }

        // Render
        window.clear(sf::Color(50, 50, 50));

        if (showMainPage) {
            window.draw(titleText);
            for (size_t i = 0; i < buttons.size(); ++i) {
                window.draw(buttons[i]);
                window.draw(buttonTexts[i]);
            }
        } else {
            sf::Text algorithmTitle;
            algorithmTitle.setFont(font);
            algorithmTitle.setString(currentAlgorithm + " Visualization");
            algorithmTitle.setCharacterSize(30);
            algorithmTitle.setFillColor(sf::Color::White);
            algorithmTitle.setPosition((view.getSize().x - algorithmTitle.getLocalBounds().width) / 2, 50);
            window.draw(algorithmTitle);

            auto& info = dataStructures[currentAlgorithm];
            sf::Text descriptionText;
            descriptionText.setFont(font);
            descriptionText.setCharacterSize(18);
            descriptionText.setFillColor(sf::Color::White);

            // Display details
            descriptionText.setString("Description: " + info.description);
            descriptionText.setPosition(50, 150);
            window.draw(descriptionText);

            descriptionText.setString("Best Case: " + info.bestComplexity);
            descriptionText.setPosition(50, 200);
            window.draw(descriptionText);

            descriptionText.setString("Average Case: " + info.averageComplexity);
            descriptionText.setPosition(50, 250);
            window.draw(descriptionText);

            descriptionText.setString("Advantages: " + info.advantages);
            descriptionText.setPosition(50, 300);
            window.draw(descriptionText);

            descriptionText.setString("Disadvantages: " + info.disadvantages);
            descriptionText.setPosition(50, 350);
            window.draw(descriptionText);

            window.draw(backButton);
            window.draw(backButtonText);
            window.draw(visualizeButton);
            window.draw(visualizeButtonText);
        }

        window.display();
    }

    return 0;
}
